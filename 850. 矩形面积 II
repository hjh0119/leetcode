class Solution {
public:
    int rectangleArea(vector<vector<int>>& rectangles) {
        int n=rectangles.size();
        vector<int> hbound;
        for(auto each:rectangles){
            hbound.push_back(each[1]);
            hbound.push_back(each[3]);
        }
        sort(hbound.begin(),hbound.end());
        hbound.erase(unique(hbound.begin(), hbound.end()), hbound.end());
        int m=hbound.size();//离散的横线数
        vector<int> seg(m-1,0);//横线间的片段

        vector<tuple<int,int,int>> sweep;//横坐标，序号，左右
        for(int i=0;i<n;++i){
            sweep.emplace_back(rectangles[i][0],i,1);
            sweep.emplace_back(rectangles[i][2],i,-1);
        }
        sort(sweep.begin(),sweep.end());

        long long ans=0;
        for(int i=0;i<sweep.size();++i){
            int j=i;
            while(j+1<sweep.size()&&get<0>(sweep[i])==get<0>(sweep[j+1]))++j;//i到j横坐标相同
            if(j+1==sweep.size())break;//最后一批要处理的边界
            for(int k=i;k<=j;++k){
                auto&& [_,idx,diff] = sweep[k];
                int left=rectangles[idx][1],right=rectangles[idx][3];//当前边界的上下纵坐标
                for(int x=0;x<m-1;++x){
                    if(left<=hbound[x]&&right>=hbound[x+1])seg[x]+=diff;
                }
            }
            int cover=0;
            for(int k=0;k<m-1;++k){
                if(seg[k]>0){
                    cover+=(hbound[k+1]-hbound[k]);
                }
            }
            ans+=(long long)cover*(get<0>(sweep[j+1])-get<0>(sweep[j]));
            i=j;
        }
        return ans % static_cast<int>(1e9 + 7);
    }
};
